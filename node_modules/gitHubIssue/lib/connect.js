"use strict";

const resources = require('./resources'),
	https = require('https'),
	url = require('url');

function GitHubConnect() {}

module.exports = GitHubConnect;

function initHeaders(token) {

	let headers = {};
	for (let a in resources.headers) {
		headers[a] = resources.headers[a];
	}
	if (token) {
		headers.Authorization = "token " + token;
	}
	return headers;
}

function rollInLocation(opts, location) {
	const redirect = url.parse(location);
	opts.hostname = redirect.hostname;
	opts.path = redirect.path;
	return opts;
}

function neatenIssues(issues) {
	return issues.map(issue => {
		let res = {
			number: issue.number,
			comments: issue.comments_url,
			web: issue.html_url,
			commentCount: issue.comments,
			events: issue.events_url,
			title: issue.title,
			created: issue.created_at,
			updated: issue.updated_at,
			closed: issue.closed_at,
			body: issue.body,
		};
		if (issue.user) {
			res.user = {
				login: issue.user.login,
				avatar: issue.user.avatar_url
			};
		}
		if (issue.labels && issue.labels.length) {
			res.labels = issue.labels.map(lab => ({
				name: lab.name,
				color: lab.color
			}));
		}
		if (issue.milestone) {
			res.milestone = {
				url: issue.milestone.url,
				number: issue.milestone.number,
				title: issue.milestone.title,
				created: issue.milestone.created_at,
				updated: issue.milestone.updated_at,
				closed: issue.milestone.closed_at
			};
		}
		if (issue.assignee) {
			res.assignee = {
				login: issue.assignee.login,
				avatar: issue.assignee.avatar_url
			};
		}
		if (issue.pull_request) {
			res.pull_request = issue.pull_request.url;
		}
		return res;
	});
}

function request(opts, inData, redirectCycle, existingData) {
	redirectCycle = redirectCycle || 0;
	existingData = existingData || [];
	return new Promise((resolve, reject) => {
		let req = https.request(opts, res => {
			if (res.statusCode >= 300 && res.statusCode < 400) {
				if (redirectCycle > 5) {
					return reject(resources.strings.redirectError);
				}
				//do the redirect
				rollInLocation(opts, res.headers.location);
				return resolve(request(opts, inData, redirectCycle + 1));
			}
			let data = [];
			let dataListener = d => data.push(d);
			let endListener = () => {
				if (!data.length) resolve({});
				try {
					existingData = existingData.concat(neatenIssues(JSON.parse(Buffer.concat(data)
						.toString())));
					if ('link' in res.headers) {
						//get the link and relevance
						let next = /<([^\>]*)>;\s*rel\="next"/.exec(res.headers.link);
						if (next) {
							next = next[1];
							rollInLocation(opts, next);
							return resolve(request(opts, inData, redirectCycle, existingData));
						}
					}
					resolve(existingData);
				} catch (e) {
					reject(e);
				}
			};
			if (res.statusCode >= 400) {
				if (resources.strings[res.statusCode]) return reject(resources.strings[res.statusCode]);
				return reject(resources.strings.unknown);
			}
			res.on('data', dataListener);
			res.on('end', endListener);
		});
		req.on('error', e => {
			reject(e);
		});
		if (inData) req.write(inData);
		req.end();
	});
}
GitHubConnect.prototype.getForkParent = function(git, token) {
	const headers = initHeaders(token);
	const opts = {
		hostname: resources.hostname,
		path: "/repos/" + git.owner + "/" + git.repo,
		method: "GET",
		headers: headers
	};
	return request(opts)
		.then(res => res.fork ? {} : {
			owner: res.parent.user.owner,
			repo: res.parent.name
		});
};
GitHubConnect.prototype.getIssues = function(git, token, since) {
	const headers = initHeaders(token);
	if (!since) since = new Date("2000-01-01");
	//if since is less than an hour ago, we get both open
	//and closed so we can remove the ones we have stored.
	let defaults = "per_page=100;";
	if (since.valueOf() + 60 * 60 * 1000 > Date.now()) {
		defaults += "state=all;";
	}
	const opts = {
		hostname: resources.hostname,
		path: "/repos/" + git.owner + "/" + git.repo + "/issues?" + defaults + "since=" + since.toISOString(),
		method: "GET",
		headers: headers
	};
	return request(opts);

};
