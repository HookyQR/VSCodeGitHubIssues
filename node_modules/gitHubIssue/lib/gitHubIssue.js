"use strict";
let Connect = require('./connect');
const resources = require('./resources');
const fs = require('fs');
const pJoin = require('path')
	.join;
//any empty reject is a 'no github'

/**
 * The issue controller, handles interation between the workers
 * 
 */
function GitHubIssues(vscode, context) {
	this._vscode = vscode;
	this._root = vscode.workspace.rootPath;
	this._context = context;
	this._projectConfig = {};
	this._gitConfig = null;
	this._gitHub = null;
	this._connection = new Connect();
	this._issueStatus = {};
	this._pullRequests = 0;
	this._prevViewDate = new Date(0);
	this._issues = [];
}
GitHubIssues.prototype.markViewed = function() {
	this._prevViewDate = new Date();
	this._context.workspaceState.update("viewdate", this._prevViewDate);
	this.showStatus();
};
const transToStore = {
	number: 'x',
	comments: 'c',
	web: 'w',
	commentCount: 'n',
	events: 'e',
	title: 't',
	body: 'b',
	user: 'u',
	labels: 'l',
	milestone: 'm',
	assignee: 'a',
	pull_request: 'p',
	created: 'C',
	updated: 'U',
	closed: 'X'
};

function dataToStore(d) {
	return d.map(itm => {
		let r = {};
		for (let a in itm) {
			if (itm[a]) r[transToStore[a]] = itm[a];
		}
		return r;
	});
}

function storeToData(d) {
	let rev = {};
	for (let a in transToStore) {
		rev[transToStore[a]] = a;
	}
	return d.map(itm => {
		let r = {};
		for (let a in itm) {
			r[rev[a]] = itm[a];
		}
		if (!r.number) r.number = 0;
		if (!r.commentCount) r.commentCount = 0;
		if (!r.comments) r.comments = "";
		if (!r.web) r.web = "";
		if (!r.events) r.events = "";
		if (!r.title) r.title = "";
		if (!r.body) r.body = "";
		return r;
	});
}

GitHubIssues.prototype.cleanData = function(newIssues) {
	return Promise.resolve()
		.then(() => {
			if (newIssues.length === 0) return;
			//update
			const realNewIssues = newIssues.filter(newIssue => (!this._issues.some((oldIssue, i) => {
				if (newIssue.number === oldIssue.number) {
					this._issues[i] = newIssue;
					return true;
				}
			})));
			//add the new
			if (realNewIssues.length) this._issues = this._issues.concat(realNewIssues);
			//drop completed issues
			this._issues = this._issues.filter(issue => !issue.closed);
			//and sort
			this._issues = this._issues.sort((a, b) =>
				a.updated === b.updated ? 0 : (a.updated > b.updated ? -1 : 1)
			);
			//we don't need to follow this
			this._context.workspaceState.update("cleanIssues", dataToStore(this._issues));
		});
};

GitHubIssues.prototype.getDataSet = function() {
	//if we haven't run yet, check if we have a stored version
	if (!this._runDate) {
		let issues = this._context.workspaceState.get("cleanIssues", null);
		if (issues) {
			this._prevRunDate = new Date(this._context.workspaceState.get("rundate", "2000-01-01"));
			this._prevViewDate = new Date(this._context.workspaceState.get("viewdate", "2000-01-01"));
			this._issues = storeToData(issues);
		}
	} else {
		this._prevRunDate = this._runDate;
	}
	let d = this._prevRunDate || new Date("2000-01-01");
	this._runDate = new Date();
	this._context.workspaceState.update("rundate", this._runDate);
	return this._connection.getIssues(this._gitHub, this._projectConfig.authToken, d)
		//remove old dupes
		.then(issues => this.cleanData(issues));
};
GitHubIssues.prototype.runFull = function() {
	return this.loadVSCodeSettings()
		.then(() => this.showLoading())
		.then(() => this.getDataSet())
		.then(() => this.loadVSCodeElements());
};
GitHubIssues.prototype.begin = function() {
	this.getGitProject()
		.then(() => this.runFull())
		.then(() => {
			//set callbacks
			this._vscode.workspace.onDidChangeConfiguration(() => {
				this.loadVSCodeSettings()
					.then(() => this.loadVSCodeElements());
			});
			this._timer = setTimeout(() => this.runFull(), (this._projectConfig.runEvery || 5) * 60 * 1000);
		})
		.catch(error => {
			//no error means it's not a git project, we
			//just leave happily
			if (!error) return;
			console.log("Error on first run:", error);
		});
};
GitHubIssues.prototype.getGitProject = function() {
	if (this._gitConfig) return Promise.resolve(this._gitConfig.githubLink);
	return new Promise((resolve, reject) =>
		fs.readFile(pJoin(this._root, ".git", "config"), 'utf8', (error, data) => {
			if (error) return reject();
			let lines = data.split('\n');
			let section = null;
			let elements = {};
			lines.forEach(line => {
				//section entry
				let match = /\[(.*?)(?:\s*"([^"]*)")?\]/.exec(line);
				if (match) {
					if (!elements[match[1]]) elements[match[1]] = {};
					section = elements[match[1]];
					if (match[2]) {
						if (!section[match[2]]) section[match[2]] = {};
						section = section[match[2]];
					}
					return;
				}
				if (!section) return;
				match = /\s*(.*?)\s*=\s*(.*)/.exec(line);
				if (!match) return;
				section[match[1]] = match[2];
				if (match[1] === 'url') {
					let tgt = match[2];
					match = /https:\/\/(?:www\.)?github.com\/([^\/]*)\/([^\/]+?)(?:\.git|$)/.exec(tgt);
					if (match) {
						this._gitHub = {
							owner: match[1],
							repo: match[2]
						};
					}
				}
			});
			this._gitConfig = elements;
			if (!this._gitHub) return reject();
			resolve();
		}));
};

GitHubIssues.prototype.loadVSCodeSettings = function() {
	return Promise.resolve()
		.then(() => {
			let newProjectConfig = this._vscode.workspace.getConfiguration('GitHubIssues');
			if (newProjectConfig.runEvery !== this._projectConfig.runEvery) {
				if (!newProjectConfig.authToken) {
					if (newProjectConfig.runEvery && newProjectConfig.runEvery < 3) newProjectConfig.runEvery = 3;
				}
				if (this._timmer) {
					clearTimeout(this._timmer);
					this._timer = setTimeout(() => this.runFull(), (newProjectConfig.runEvery || 5) * 60 * 1000);
				}
			}

			//status bar alignment - only need to do this if it has changed
			if (!this._statusBar || newProjectConfig.statusPos !== this._projectConfig.statusPos) {
				if (this._statusBar) {
					this._statusBar.hide();
					this._statusBar.dispose();
				}
				this._statusBar = this.buildStatus(newProjectConfig.statusPos === 'right' ? this._vscode.StatusBarAlignment
					.Right : this._vscode.StatusBarAlignment.Left);
			}
			this._projectConfig = newProjectConfig;
			//config needs to be checked
			if (!this._projectConfig.showLabelAs) this._projectConfig.showLabelAs = {
				bug: 'bug',
				Unlabelled: 'info'
			};
			//check that the label icons are all from the set. Don't clear them, 
			//just set to circle-slash
			for (let a in this._projectConfig.showLabelAs) {
				if (resources.icons.indexOf(this._projectConfig.showLabelAs[a]) < 0) this._projectConfig.showLabelAs[a] =
					"circle-slash";
			}
			if (!('assignee' in this._projectConfig)) this._projectConfig.assignee = 'all';
			if (!('countInAllLabels' in this._projectConfig)) this._projectConfig.countInAllLabels = true;
			if (!('showPullRequests' in this._projectConfig)) this._projectConfig.showPullRequests = true;
		});
};

GitHubIssues.prototype.loadVSCodeElements = function() {
	return Promise.resolve()
		.then(() => this.calculateIssues())
		.then(() => this.showStatus())
		.then(() => this.fillRootMarkdown());
};

function ensureDirectory(name) {
	return new Promise((resolve, reject) => {
		fs.stat(name, (err, stat) => {
			if (err && err.code === "ENOENT") {
				//make it
				fs.mkdir(name, err => {
					if (err) return reject(err);
					resolve();
				});
				return;
			}
			if (err) return reject(err);
			if (!stat.isDirectory()) {
				err = new Error("Must be a directory: .vscode");
				err.code = "EEXIST";
				return reject(err);
			}
			resolve();
		});
	});
}

function markDownIssue(issue) {
	let md = "# #" + issue.number + ": [" + issue.title + "](" + issue.web + ")\n\n";
	if (issue.labels) {
		issue.labels.forEach(label => {
			md += "<div class='label' style='background-color:#" + label.color + "'>" + label.name + "</div> ";
		});
		md += "\n\n";
	}
	if (issue.pull_request) md += "***Pull Request***  &nbsp; ";
	if (issue.user) md += "**User:** " + issue.user.login + "  &nbsp; ";
	if (issue.assignee) md += "**Assignee:** " + issue.assignee.login;
	md += "\n\n";
	if (issue.updated && issue.created !== issue.updated) md += "**Updated:** " + issue.updated + "  &nbsp; ";
	md += "**Created:** " + issue.created;
	if (issue.milestone) md += "\n\n**Milestone: " + issue.milestone.title + "**";
	if (issue.body) {
		md += "\n\n<hr>\n\n";
		md += issue.body;
	}
	if (issue.commentCount) {
		md += "\n\n<hr>\n\n";
		md += "Comments: " + issue.commentCount;
	}
	return md;
}

GitHubIssues.prototype.fillRootMarkdown = function() {
	//make sure the path is there:
	let root = pJoin(this._root, '.vscode');
	return ensureDirectory(root)
		.then(() => {
			root = pJoin(root, "GitHubIssue");
			return ensureDirectory(root);
		})
		.then(() => {
			return new Promise((resolve, reject) => {
				fs.writeFile(pJoin(root, "issueList.md"), this._reportedIssues.map(markDownIssue)
					.join("\n\n<hr>\n\n") + "\n\n<style>" + resources.style + "</style>", err => {
						if (err) return reject(err);
						resolve();
					});
			});
		})
		.catch(err => {
			console.log("Error making md", err);
		});
};
GitHubIssues.prototype.buildStatus = function(side) {
	let status = this._vscode.window.createStatusBarItem(side, 50);
	status.command = "HookyQR.GitHubIssues";
	status.tooltip = "Show GitHub Issues";
	return status;
};
GitHubIssues.prototype.calculateIssues = function() {
	const assign = this._projectConfig.assignee;
	const labelSet = this._projectConfig.showLabelAs;
	this._issueStatus = {};
	for (let l in labelSet) {
		this._issueStatus[labelSet[l]] = {
			count: 0,
			date: ""
		};
	}
	this._pullRequests = {
		count: 0,
		date: ""
	};
	this._reportedIssues = [];
	this._issues.forEach(issue => {
		let added = false;
		//if we're on all for pull requests, add it here
		if (issue.pull_request && this._projectConfig.showPullRequests === 'all') {
			this._pullRequests.count++;
			if (issue.created > this._pullRequests.date) {
				this._pullRequests.date = issue.created;
			}
			if (issue.updated > this._pullRequests.date) {
				this._pullRequests.date = issue.updated;
			}
			this._reportedIssues.push(issue);
			added = true;
		}
		//is this in our assignee list?
		if (assign !== 'all') {
			//null is only unassigned
			if (assign === null && issue.assignee) return;
			//specific individual
			if (typeof assign === 'string' && (!issue.assignee || issue.assignee.login !== assign)) return;
			if (Array.isArray(assign)) {
				//we're an array
				if (!issue.assignee && assign.indexOf(null) < 0) return;
				//we have to have the assignee in the list
				if (issue.assignee && assign.indexOf(issue.assignee.login) < 0) return;
			}
		}
		//if we're here, and we're showing pull requests, but not all of them, add it now
		if (issue.pull_request && this._projectConfig.showPullRequests === true) {
			this._pullRequests.count++;
			if (issue.created > this._pullRequests.date) {
				this._pullRequests.date = issue.created;
			}
			if (issue.updated > this._pullRequests.date) {
				this._pullRequests.date = issue.updated;
			}
			this._reportedIssues.push(issue);
			added = true;
		}
		if (!issue.labels) {
			if (labelSet.Unlabelled) {
				this._issueStatus[labelSet.Unlabelled].count++;
				if (issue.created > this._issueStatus[labelSet.Unlabelled].date) {
					this._issueStatus[labelSet.Unlabelled].date = issue.created;
				}
				if (issue.updated > this._issueStatus[labelSet.Unlabelled].date) {
					this._issueStatus[labelSet.Unlabelled].date = issue.updated;
				}
				if (!added) this._reportedIssues.push(issue);
			}
		} else {
			let issueNames = issue.labels.map(l => l.name);
			if (this._projectConfig.countInAllLabels) {
				let tagUsed = [];
				issueNames.forEach(name => {
					//if we're counting in all tags, not the labels - some may be multi used:
					if (name in labelSet) {
						if (tagUsed.indexOf(labelSet[name]) < 0) {
							tagUsed.push(labelSet[name]);
						}
						if (issue.created > this._issueStatus[labelSet[name]].date) {
							this._issueStatus[labelSet[name]].date = issue.created;
						}
						if (issue.updated > this._issueStatus[labelSet[name]].date) {
							this._issueStatus[labelSet[name]].date = issue.updated;
						}
					}
				});
				tagUsed.forEach(tag => this._issueStatus[tag].count++);
				if (tagUsed.length && !added) this._reportedIssues.push(issue);

			} else {
				//we run it the other way
				let keys = Object.keys(labelSet);
				let choice = null;
				keys.some(k => issueNames.indexOf(k) >= 0 ? (choice = k) : null);
				if (choice) {
					this._issueStatus[labelSet[choice]].count++;
					if (issue.created > this._issueStatus[labelSet[choice]].date) {
						this._issueStatus[labelSet[choice]].date = issue.created;
					}
					if (issue.updated > this._issueStatus[labelSet[choice]].date) {
						this._issueStatus[labelSet[choice]].date = issue.updated;
					}
					if (!added) this._reportedIssues.push(issue);
				}
			}
		}
	});
};
GitHubIssues.prototype.showLoading = function() {
	//we only show loading on the first run
	if (!this._timer) {
		this._statusBar.text = "$(mark-github)  Loading";
		this._statusBar.show();
	}
};
GitHubIssues.prototype.showStatus = function() {
	let text = "$(mark-github)  ";
	if (this._projectConfig.showPullRequests && this._pullRequests.count) text += "$(git-pull-request)" + (new Date(this._pullRequests
			.date) > this._prevViewDate ? "* " : "  ") + this._pullRequests
		.count + "  ";
	let keys = Object.keys(this._issueStatus);
	keys = keys.filter(key => this._issueStatus[key].count);
	if (keys.length === 0 && (!this._projectConfig.showPullRequests || !this._pullRequests)) text += "$(check)";
	else text += keys.map(key => "$(" + key + ")" + (new Date(this._issueStatus[key].date) >
			this._prevViewDate ? "* " : " ") + this._issueStatus[key].count)
		.join("  ");
	this._statusBar.text = text;
	this._statusBar.show();
};

module.exports = GitHubIssues;
