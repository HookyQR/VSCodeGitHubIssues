"use strict";
var view = require('./view');
var Connect = require('./connect');
var resources = require('./resources');

var fs = require('fs');
var pJoin = require('path')
	.join;
//any empty reject is a 'no github'

/*
	Config options:
		statusPos: "left","right"
		countInAllLabels: true,false
		showLabelAs: {
			{label}: any of "https://octicons.github.com"
		}
		showPullRequests: 'all',true,false
		assignee: [null, login], 'all',null, login
	Defaults:
		statusPos: "left",
		countInAllLabels: true,
		showLabelAs:{
			bug: 'bug',
			Unlabelled: 'info'
		},
		showPullRequests: true,
		assignee: 'all',
		runEvery:5
*/
function GitHubIssues(vscode, context) {
	this._vscode = vscode;
	this._root = vscode.workspace.rootPath;
	this._context = context;
	this._projectConfig = {};
	this._gitConfig = null;
	this._gitHub = null;
	this._connection = new Connect();
	this._issueStatus = {};
	this._pullRequests = 0;
	this._issues = [];

	view;

}

GitHubIssues.prototype.cleanData = function(newIssues) {
	return Promise.resolve()
		.then(() => {
			if (newIssues.length === 0) return;
			//update
			var realNewIssues = newIssues.filter(newIssue => (!this._issues.some((oldIssue, i) => {
				if (newIssue.number === oldIssue.number) {
					this._issues[i] = newIssue;
					return true;
				}
			})));
			//add the new
			if (realNewIssues.length) this._issues = this._issues.concat(realNewIssues);
			//drop completed issues
			this._issues = this._issues.filter(issue => !issue.closed);
			//and sort
			this._issues = this._issues.sort((a, b) =>
				a.updated === b.updated ? 0 : (a.updated > b.updated ? -1 : 1)
			);
		});
};

GitHubIssues.prototype.getDataSet = function() {
	var d = this._runDate || new Date("2000-01-01");
	this._runDate = new Date();
	return this._connection.getIssues(this._gitHub, this._projectConfig.authToken, d)
		//remove old dupes
		.then(issues => this.cleanData(issues));
};
GitHubIssues.prototype.runFull = function() {
	return this.loadVSCodeSettings()
		.then(() => this.showLoading())
		.then(() => this.getDataSet())
		.then(() => this.loadVSCodeElements());
};
GitHubIssues.prototype.begin = function() {
	this.getGitProject()
		.then(() => this.runFull())
		.then(() => {
			this._vscode.workspace.onDidChangeConfiguration(() => {
				this.loadVSCodeSettings()
					.then(() => this.loadVSCodeElements());
			});

			this._timer = setTimeout(() => this.runFull(), (this._projectConfig.runEvery || 5) * 60 * 1000);
		})
		.catch(error => {
			//no error means it's not a git project, we
			//just leave happily
			if (!error) return;
			console.log("Error on first run:", error);
		});
};
GitHubIssues.prototype.getGitProject = function() {
	if (this._gitConfig) return Promise.resolve(this._gitConfig.githubLink);
	return new Promise((resolve, reject) =>
		fs.readFile(pJoin(this._root, ".git", "config"), 'utf8', (error, data) => {
			if (error) return reject();
			var lines = data.split('\n');
			var section = null;
			var elements = {};
			lines.forEach(line => {
				//section entry
				let match = /\[(.*?)(?:\s*"([^"]*)")?\]/.exec(line);
				if (match) {
					if (!elements[match[1]]) elements[match[1]] = {};
					section = elements[match[1]];
					if (match[2]) {
						if (!section[match[2]]) section[match[2]] = {};
						section = section[match[2]];
					}
					return;
				}
				if (!section) return;
				match = /\s*(.*?)\s*=\s*(.*)/.exec(line);
				if (!match) return;
				section[match[1]] = match[2];
				if (match[1] === 'url') {
					var tgt = match[2];
					match = /https:\/\/(?:www\.)?github.com\/([^\/]*)\/([^\/]+?)(?:\.git)|$/.exec(tgt);
					if (match) {
						this._gitHub = {
							owner: match[1],
							repo: match[2]
						};
					}
				}
			});
			this._gitConfig = elements;
			if (!this._gitHub) return reject();
			resolve();
		}));
};

GitHubIssues.prototype.loadVSCodeSettings = function() {
	return Promise.resolve()
		.then(() => {
			var newProjectConfig = this._vscode.workspace.getConfiguration('GitHubIssues');
			if (newProjectConfig.runEvery !== this._projectConfig.runEvery) {
				if (!newProjectConfig.authToken) {
					if (newProjectConfig.runEvery && newProjectConfig.runEvery < 3) newProjectConfig.runEvery = 3;
				}
				if (this._timmer) {
					clearTimeout(this._timmer);
					this._timer = setTimeout(() => this.runFull(), (newProjectConfig.runEvery || 5) * 60 * 1000);
				}
			}

			//status bar alignment - only need to do this if it has changed
			if (!this._statusBar || newProjectConfig.statusPos !== this._projectConfig.statusPos) {
				if (this._statusBar) {
					this._statusBar.hide();
					this._statusBar.dispose();
				}
				this._statusBar = this.buildStatus(newProjectConfig.statusPos === 'right' ? this._vscode.StatusBarAlignment
					.Right : this._vscode.StatusBarAlignment.Left);
			}
			this._projectConfig = newProjectConfig;
			//config needs to be checked
			if (!this._projectConfig.showLabelAs) this._projectConfig.showLabelAs = {
				bug: 'bug',
				Unlabelled: 'info'
			};
			//check that the label icons are all from the set. Don't clear them, 
			//just set to circle-slash
			for (let a in this._projectConfig.showLabelAs) {
				if (resources.icons.indexOf(this._projectConfig.showLabelAs[a]) < 0) this._projectConfig.showLabelAs[a] =
					"circle-slash";
			}
			if (!('assignee' in this._projectConfig)) this._projectConfig.assignee = 'all';
			if (!('countInAllLabels' in this._projectConfig)) this._projectConfig.countInAllLabels = true;
			if (!('showPullRequests' in this._projectConfig)) this._projectConfig.showPullRequests = true;
		});
};

GitHubIssues.prototype.loadVSCodeElements = function() {
	return Promise.resolve()
		.then(() => this.calculateIssues())
		.then(() => this.showStatus())
		.then(() => this.fillRootMarkdown());
};

function ensureDirectory(name) {
	return new Promise((resolve, reject) => {
		fs.stat(name, (err, stat) => {
			if (err && err.code === "ENOENT") {
				//make it
				fs.mkdir(name, err => {
					if (err) return reject(err);
					resolve();
				});
				return;
			}
			if (err) return reject(err);
			if (!stat.isDirectory()) {
				err = new Error("Must be a directory: .vscode");
				err.code = "EEXIST";
				return reject(err);
			}
			resolve();
		});
	});
}

function markDownIssue(issue) {
	var md = "# #" + issue.number + ": [" + issue.title + "](" + issue.web + ")\n\n";
	if (issue.labels) {
		issue.labels.forEach(label => {
			md += "<div class='label' style='background-color:#" + label.color + "'>" + label.name + "</div> ";
		});
		md += "\n\n";
	}
	if (issue.pull_request) md += "***Pull Request***  ";

	if (issue.user) md += "**User:** " + issue.user.login + "  ";
	md += "\n\n";
	if (issue.assignee) md += "**Assignee:** " + issue.assignee.login + "  ";

	if (issue.milestone) md += "**Milestone: " + issue.milestone.title + "**  ";
	md += "**Created:** " + issue.created;
	if (issue.updated && issue.created !== issue.updated) md += "  **Updated:** " + issue.updated;
	md += "\n\n<hr>\n\n";
	md += issue.body;
	if (issue.commentCount) {
		md += "\n\n<hr>\n\n";
		md += "Comments: " + issue.commentCount;
	}
	return md;
}

GitHubIssues.prototype.fillRootMarkdown = function() {
	//make sure the path is there:
	var root = pJoin(this._root, '.vscode');
	return ensureDirectory(root)
		.then(() => {
			root = pJoin(root, "GitHubIssue");
			return ensureDirectory(root);
		})
		.then(() => {
			return new Promise((resolve, reject) => {
				fs.writeFile(pJoin(root, "issueList.md"), this._reportedIssues.map(markDownIssue)
					.join("\n\n<hr>\n\n") + "\n\n<style>" + resources.style + "</style>", err => {
						if (err) return reject(err);
						resolve();
					});
			});
		})
		.catch(err => {
			console.log("Error making md", err);
		});
};
GitHubIssues.prototype.buildStatus = function(side) {
	var status = this._vscode.window.createStatusBarItem(side, 0);
	status.command = "HookyQR.GitHubIssues";
	status.tooltip = "Show GitHub Issues";
	return status;
};
GitHubIssues.prototype.calculateIssues = function() {
	var assign = this._projectConfig.assignee;
	var labelSet = this._projectConfig.showLabelAs;
	this._issueStatus = {};
	for (let l in labelSet) {
		this._issueStatus[labelSet[l]] = 0;
	}
	this._pullRequests = 0;
	this._reportedIssues = [];
	this._issues.forEach(issue => {
		let added = false;
		//if we're on all for pull requests, add it here
		if (issue.pull_request && this._projectConfig.showPullRequests === 'all') {
			this._pullRequests++;
			this._reportedIssues.push(issue);
			added = true;
		}
		//is this in our assignee list?
		if (assign !== 'all') {
			//null is only unassigned
			if (assign === null && issue.assignee) return;
			//specific individual
			if (typeof assign === 'string' && (!issue.assignee || issue.assignee.login !== assign)) return;
			if (Array.isArray(assign)) {
				//we're an array
				if (!issue.assignee && assign.indexOf(null) < 0) return;
				//we have to have the assignee in the list
				if (issue.assignee && assign.indexOf(issue.assignee.login) < 0) return;
			}
		}
		//if we're here, and we're showing pull requests, but not all of them, add it now
		if (issue.pull_request && this._projectConfig.showPullRequests === true) {
			this._pullRequests++;
			this._reportedIssues.push(issue);
			added = true;
		}
		if (!issue.labels) {
			if (labelSet.Unlabelled) {
				this._issueStatus[labelSet.Unlabelled]++;
				if (!added) this._reportedIssues.push(issue);
			}
		} else {
			var issueNames = issue.labels.map(l => l.name);
			if (this._projectConfig.countInAllLabels) {
				let tagUsed = [];
				issueNames.forEach(label => {
					//if we're counting in all tags, not the labels - some may be multi used:
					if (label in labelSet && tagUsed.indexOf(labelSet[label]) < 0) tagUsed.push(labelSet[label]);
				});
				tagUsed.forEach(tag => this._issueStatus[tag]++);
				if (tagUsed.length && !added) this._reportedIssues.push(issue);

			} else {
				//we run it the other way
				var keys = Object.keys(labelSet);
				var choice = null;
				keys.some(k => issueNames.indexOf(k) >= 0 ? (choice = k) : null);
				if (choice) {
					this._issueStatus[choice]++;
					if (!added) this._reportedIssues.push(issue);
				}
			}
		}
	});
};
GitHubIssues.prototype.showLoading = function() {
	//we only show loading on the first run
	if (!this._timer) {
		this._statusBar.text = "$(mark-github)  Loading";
		this._statusBar.show();
	}
};
GitHubIssues.prototype.showStatus = function() {
	let text = "$(mark-github)  ";
	if (this._projectConfig.showPullRequests && this._pullRequests) text += "$(git-pull-request) " + this._pullRequests +
		"  ";
	var keys = Object.keys(this._issueStatus);
	keys = keys.filter(key => this._issueStatus[key]);
	if (keys.length === 0 && (!this._projectConfig.showPullRequests || !this._pullRequests)) text += "$(check)";
	else text += keys.map(key => "$(" + key + ") " + this._issueStatus[key])
		.join("  ");
	this._statusBar.text = text;
	this._statusBar.show();
};

module.exports = GitHubIssues;
